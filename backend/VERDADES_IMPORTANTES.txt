â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘               RUTAS SEGURAS - VERDADES IMPORTANTES DEL BACKEND                â•‘
â•‘                  Puntos clave que debes conocer y recordar                    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
VERDAD #1: EL JWT EXPIRA DESPUÃ‰S DE 24 HORAS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

IMPORTANCIA: CRÃTICA ğŸ”´

QUÃ‰ SIGNIFICA:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Cuando un usuario inicia sesiÃ³n, recibe un token JWT.
Este token es vÃ¡lido durante 24 horas.
DespuÃ©s de 24 horas, el token expira automÃ¡ticamente.

POR QUÃ‰ SE HACE ASÃ:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RazÃ³n 1: SEGURIDAD
  - Si alguien roba un token, solo lo puede usar 24 horas
  - Reduce ventana de vulnerabilidad

RazÃ³n 2: PROTOCOLO JWT
  - JWT es stateless (sin estado servidor)
  - No se puede "revocar" un token en tiempo real
  - La Ãºnica forma es esperar que expire

RazÃ³n 3: BALANCE
  - 24h es balance entre seguridad y experiencia
  - Enough para sesiÃ³n de un dÃ­a
  - No tan largo que sea riesgo

QUÃ‰ HACER:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
En React, cuando recibas error 401:
1. Limpiar localStorage del token
2. Redirigir a /login
3. Mostrar mensaje: "SesiÃ³n expirada, inicia sesiÃ³n nuevamente"

CÃ“DIGO REACT:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
useEffect(() => {
  if (response.status === 401) {
    localStorage.removeItem('token');
    navigate('/login');
  }
}, [response]);

Â¿CÃ“MO MEJORAR ESTO?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FUTURO: Implementar refresh tokens
  - Token principal (short-lived): 1 hora
  - Refresh token (long-lived): 30 dÃ­as
  - Cuando principal expira, usar refresh para renovar
  - Sin hacer login otra vez

Pero eso estÃ¡ FUERA DE ESTE PROYECTO (es feature extra).


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
VERDAD #2: EL JWT_SECRET ES LA LLAVE MAESTRA
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

IMPORTANCIA: CRÃTICA ğŸ”´

QUÃ‰ ES:
â”€â”€â”€â”€â”€â”€â”€
Variable en config/config.php:
define('JWT_SECRET', 'tu_secreto_aqui');

Este secret es la LLAVE para:
  âœ… Firmar (generar) tokens
  âœ… Verificar (validar) tokens

SIN EL SECRET:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ No se pueden generar tokens seguros
âŒ No se puede verificar si un token es genuino
âŒ Alguien puede falsificar tokens

SI ALGUIEN ROBA EL SECRET:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ Puede generar tokens falsos
âŒ Se harÃ­a pasar por cualquier usuario
âŒ Sistema de seguridad completamente comprometido

POR ESO:
â”€â”€â”€â”€â”€â”€â”€â”€
âœ… En PRODUCCIÃ“N, DEBE SER ÃšNICO Y FUERTE
âœ… NO debe ser "secret123" o similar
âœ… Genera con: php -r "echo bin2hex(random_bytes(32));"
âœ… Ejemplo: 7e2b3a1c9d5f4e8b6a2c0d9e1f3a5b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f

DÃ“NDE GUARDARLO:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ NO en GitHub (pÃºblicamente)
âŒ NO en archivos compartidos
âœ… SÃ en config.php (servidor privado)
âœ… SÃ en variables de entorno (producciÃ³n)

CÃ“MO CAMBIAR EN PRODUCCIÃ“N:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Si alguien roba el secret:
1. Todos los tokens vigentes quedan INVALIDADOS
2. Cambiar JWT_SECRET en config.php
3. Todos los usuarios deben hacer login nuevamente
4. Problema resuelto


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
VERDAD #3: LA CONTRASEÃ‘A NUNCA SE GUARDA EN TEXTO PLANO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

IMPORTANCIA: CRÃTICA ğŸ”´

QUÃ‰ SUCEDE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Usuario ingresa: "MiPass123!"
                    â–¼ Backend ejecuta
                password_hash("MiPass123!", PASSWORD_BCRYPT, ['cost' => 12])
                    â–¼ Resultado
        "$2y$12$mIVVPPMR8PJNvHjN5uC8jO.NjYQmzJVCsKzQ0..."

ESTO SE GUARDA EN BD:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ NO: "MiPass123!"  â† Nunca en texto plano
âœ… SÃ: "$2y$12$..." â† Hash irreversible

POR QUÃ‰:
â”€â”€â”€â”€â”€â”€â”€â”€
RazÃ³n 1: NO REVERSIBLE
  - No se puede "desencryptar" el hash
  - Nadie (ni el admin) puede ver la contraseÃ±a original
  - Si alguien roba BD, no obtiene contraseÃ±as

RazÃ³n 2: CADA VEZ DIFERENTE
  - Mismo password genera hash diferente
  - Esto se llama "salt"
  - Frena ataques con diccionarios

RazÃ³n 3: LENTO
  - BCRYPT con cost 12 = ~1 segundo por hash
  - Frena ataques brute force (probar millones de passwords)
  - Sin BCRYPT: 1000 intentos por segundo
  - Con BCRYPT: 1 intento por segundo

CÃ“MO SE VALIDA:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Usuario hace login: email="juan@mail.com", password="MiPass123!"
                    â–¼ Backend ejecuta
        password_verify("MiPass123!", "$2y$12$...")
                    â–¼ Compara
        Â¿El hash generado de "MiPass123!" coincide con el guardado?
                    â–¼ Resultado
        SÃ: âœ… Login correcto
        NO: âŒ ContraseÃ±a incorrecta

IMPORTANTE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ NO se puede recuperar contraseÃ±a original
âœ… SOLO se puede resetear a una nueva

Si usuario olvida:
  1. Enviar email con link reset
  2. Usuario ingresa nueva contraseÃ±a
  3. Se hashea la nueva con BCRYPT
  4. Se reemplaza el hash viejo


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
VERDAD #4: LA BD ES LA FUENTE DE LA VERDAD
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

IMPORTANCIA: ALTA ğŸŸ¡

QUÃ‰ SIGNIFICA:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Lo que estÃ¡ en la BD es la VERDAD.
Lo que estÃ¡ en localStorage es copia/cache.

EJEMPLO:
â”€â”€â”€â”€â”€â”€â”€â”€
Usuario en PC1:
  localStorage = { user: { name: "Juan", email: "juan@..." } }

Administrador edita datos en BD:
  BD.usuarios.name = "Juan Carlos Actualizado"

Usuario sigue viendo en PC1:
  localStorage sigue mostrando: "Juan" (obsoleto)

Â¿CUÃL ES LA VERDAD?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… VERDAD: "Juan Carlos Actualizado" (en BD)
âŒ FALSO: "Juan" (en localStorage)

POR QUÃ‰:
â”€â”€â”€â”€â”€â”€â”€â”€
localStorage es tan solo cache local.
Si mÃºltiples dispositivos acceden:
  PC1: Puede ver datos diferentes de PC2
  PC2: Tiene su propia copia de localStorage
  
Pero si llamas a /api/auth/me:
  Ambos obtienen datos ACTUALIZADOS de la BD

IMPLICACIÃ“N:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DespuÃ©s de cualquier acciÃ³n importante:
  âœ… Recargar datos desde servidor
  âœ… Actualizar localStorage con respuesta
  âœ… Mostrar datos actualizados

CÃ“DIGO REACT:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âŒ MAL
const name = localStorage.getItem('user').name; // PodrÃ­a estar viejo

// âœ… BIEN
const response = await api.auth.me();
setUser(response.data);
localStorage.setItem('user', JSON.stringify(response.data));


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
VERDAD #5: CORS ES TU MEJOR AMIGO (Y ENEMIGO)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

IMPORTANCIA: ALTA ğŸŸ¡

CORS = Cross-Origin Resource Sharing

QUÃ‰ ES:
â”€â”€â”€â”€â”€â”€â”€â”€
Control de quiÃ©n puede hacer requests a tu backend.

ESCENARIOS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Frontend en localhost:3000
   Backend en localhost:8000
   âŒ CORS BLOQUEA (diferentes puertos)

2. Frontend en https://app.netlify.app
   Backend en https://backend.com
   âŒ CORS BLOQUEA (diferentes dominios)

3. Frontend en malicious.com
   Backend en https://backend.com
   âŒ CORS BLOQUEA (intruso bloqueado)

CÃ“MO SE CONFIGURA:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
En backend/config/config.php:

define('FRONTEND_URL', 'https://app.netlify.app');

En .htaccess (Apache):
  Header always set "Access-Control-Allow-Origin" "https://app.netlify.app"

Â¿QUÃ‰ PASA?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Si request viene de https://app.netlify.app:
  âœ… Header Access-Control-Allow-Origin = https://app.netlify.app
  âœ… Frontend recibe respuesta
  âœ… Request exitoso

Si request viene de malicious.com:
  âŒ Header Access-Control-Allow-Origin â‰  malicious.com
  âŒ Frontend BLOQUEA respuesta (aunque servidor la envÃ­a)
  âŒ Error: "CORS policy blocked"

IMPORTANTE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… En desarrollo: Usa localhost
âœ… En producciÃ³n: Usa tu dominio Netlify
âŒ NUNCA uses "*" (wildcard) â†’ Inseguro


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
VERDAD #6: LAS VALIDACIONES SON EN 3 NIVELES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

IMPORTANCIA: ALTA ğŸŸ¡

NIVEL 1: FRONTEND (React)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Validaciones locales:
  âœ… Email vÃ¡lido: "@" y "." presentes
  âœ… ContraseÃ±a: no vacÃ­a
  âœ… Campos requeridos llenos

PropÃ³sito: UX mejor (feedback inmediato)
Seguridad: âŒ DÃ‰BIL (usuario puede saltarse)

NIVEL 2: MIDDLEWARE (Backend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Validaciones de entrada:
  âœ… JSON vÃ¡lido
  âœ… Content-Type correcto
  âœ… Campos requeridos presentes

PropÃ³sito: Evitar errores parsing
Seguridad: MEDIA (evita crashes)

NIVEL 3: LÃ“GICA DE NEGOCIO (Backend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Validaciones de reglas:
  âœ… Email Ãºnico
  âœ… ContraseÃ±a suficientemente fuerte
  âœ… Formato telÃ©fono vÃ¡lido
  âœ… Recurso existe
  âœ… Usuario tiene permiso

PropÃ³sito: Integridad de datos
Seguridad: âœ… FUERTE (insalvable)

NIVEL 4: BD (MySQL)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Validaciones de constraints:
  âœ… UNIQUE (email no duplicado)
  âœ… NOT NULL (campos obligatorios)
  âœ… FOREIGN KEY (relaciones vÃ¡lidas)
  âœ… CHECK (valores permitidos)

PropÃ³sito: Ãšltima lÃ­nea de defensa
Seguridad: âœ… INSALVABLE

POR QUÃ‰ 4 NIVELES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Defensa en profundidad = Seguridad robusta

Si un atacante:
  âŒ Salta validaciÃ³n frontend (fÃ¡cil en dev tools)
  âœ… Validaciones middleware lo atrapan
  
  âŒ Modifica middleware
  âœ… LÃ³gica de negocio lo atrapan
  
  âŒ Modifica lÃ³gica de negocio
  âœ… Constraints de BD lo atrapan


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
VERDAD #7: NUNCA EXPONGAS DETALLES DE ERROR EN PRODUCCIÃ“N
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

IMPORTANCIA: CRÃTICA ğŸ”´

DESARROLLADOR PODRÃA HACER:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
echo "Error: " . $exception->getMessage();
// Output: "Error: Table 'rutas_seguras.usuarios' doesn't exist"

PROBLEMAS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ Expone estructura de BD (nombres tablas)
âŒ Expone tecnologÃ­a (MySQL, PHP)
âŒ Facilita ataques SQL injection
âŒ Facilita ataques de fuerza bruta

DÃ“NDE LO HICIMOS CORRECTAMENTE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
En controllers/AuthController.php:

try {
  // cÃ³digo que puede fallar
} catch (Exception $e) {
  // âŒ NO: return Response::error($e->getMessage());
  // âœ… SÃ: return Response::error("Error al procesar solicitud");
}

EN FRONTEND, USUARIO VE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{
  "success": false,
  "message": "Error al procesar solicitud",
  "error": "Internal Server Error"
}

EN BACKEND, ADMIN VE (logs):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
backend/logs/error_2026-02-04.log:
[2026-02-04 10:30:45] Error: Table 'rutas_seguras.usuarios' doesn't exist
  Stack: ...
  File: models/User.php line 45
  Context: $db->query($sql, $params)

QUÃ‰ RESULTADO:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… Usuario ve mensaje genÃ©rico (seguro)
âœ… Admin puede debuggear viendo logs
âœ… InformaciÃ³n sensible no exponible


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
VERDAD #8: EL SOFT DELETE PRESERVA DATOS PARA AUDITORÃA
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

IMPORTANCIA: MEDIA ğŸŸ¡

QUÃ‰ ES SOFT DELETE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
En lugar de DELETE, se actualiza un campo "activo":

âŒ HARD DELETE (elimina completamente):
DELETE FROM usuarios WHERE id = 5;
Resultado: Usuario 5 desaparece de BD
Problema: No hay historial, imposible auditar

âœ… SOFT DELETE (marca como inactivo):
UPDATE usuarios SET activo = 0 WHERE id = 5;
Resultado: Usuario 5 "existe" pero marcado inactivo

DÃ“NDE LO USAMOS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
En BD schema:
  ALTER TABLE usuarios ADD COLUMN activo INT(1) DEFAULT 1;

En queries:
  SELECT * FROM usuarios WHERE activo = 1;  â† Solo activos

VENTAJAS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… AuditorÃ­a: Puedes ver quÃ© se "eliminÃ³"
âœ… Compliance: Cumple regulaciones (GDPR, etc)
âœ… RecuperaciÃ³n: Puedes "restaurar" si es error
âœ… Historial: Mantiene integridad de referencias

DESVENTAJAS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ MÃ¡s datos en BD (no se eliminan)
âŒ Queries mÃ¡s complejas (siempre WHERE activo = 1)
âŒ ConfusiÃ³n si no se documenta

FUTURO:
â”€â”€â”€â”€â”€â”€â”€â”€
â³ Hard delete puede agregarse como feature:
  - Admin-only
  - Solo despuÃ©s de 30 dÃ­as
  - Con confirmaciÃ³n


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
VERDAD #9: DATABASE CLASS USA SINGLETON PATTERN
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

IMPORTANCIA: MEDIA ğŸŸ¡

QUÃ‰ ES SINGLETON:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
PatrÃ³n que GARANTIZA una sola instancia de clase en toda la aplicaciÃ³n.

EN NUESTRO CÃ“DIGO:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Database {
    private static $instance = null;
    
    public static function getInstance() {
        if (self::$instance === null) {
            self::$instance = new Database();
        }
        return self::$instance;
    }
}

CÃ“MO SE USA:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
$db = Database::getInstance();  â† Primera vez: crea instancia
$db = Database::getInstance();  â† Segunda vez: retorna la MISMA instancia

BENEFICIOS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… Una sola conexiÃ³n a BD (eficiente)
âœ… No se abre mÃºltiples conexiones
âœ… Reutiliza la misma conexiÃ³n PDO
âœ… Reduce overhead

CÃ“MO NO HACERLO:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ $db = new Database();        â† MÃºltiples instancias
âŒ $db = new Database();        â† MÃºltiples conexiones
âŒ $db = new Database();        â† Desperdicia recursos

IMPORTANTE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Nunca hagas:
  public function __construct() {  // â† Constructor PRIVADO en Database.php
    // ...
  }

Eso previene:
  âŒ $db = new Database();  â† Error: Constructor privado


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
VERDAD #10: PREPARED STATEMENTS PREVIENEN SQL INJECTION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

IMPORTANCIA: CRÃTICA ğŸ”´

SQL INJECTION = Ataque insertando SQL malicioso

VULNERABLE (NO HACER):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
$email = $_GET['email'];  // "admin@mail.com' OR '1'='1"
$sql = "SELECT * FROM usuarios WHERE email = '" . $email . "'";
// Resultado: SELECT * FROM usuarios WHERE email = 'admin@mail.com' OR '1'='1'
// âŒ Devuelve TODOS los usuarios

PROTEGIDO (LO QUE HACEMOS):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
$email = $_GET['email'];
$sql = "SELECT * FROM usuarios WHERE email = ?";
$stmt = $pdo->prepare($sql);
$stmt->execute([$email]);
// Resultado: El motor de BD sabe que $email es PARÃMETRO
// âœ… Ejecuta: SELECT * FROM usuarios WHERE email = 'admin@mail.com' OR '1'='1'
//    Pero como STRING LITERAL, no como SQL

CÃ“MO FUNCIONA:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Prepared statement en 2 fases:

FASE 1 (Prepare):
  $sql = "SELECT * FROM usuarios WHERE email = ?"
  â† Motor de BD entiende estructura SQL

FASE 2 (Execute):
  $stmt->execute(['admin@mail.com' OR '1'='1'])
  â† Motor sabe que TODO es valor, no SQL

POR ESO FUNCIONA:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ NO: SELECT * WHERE email = 'admin' OR '1'='1'  â† SQL se ejecuta
âœ… SÃ: SELECT * WHERE email = 'admin\' OR \'1\'=\'1'  â† Escapeado

EN NUESTRO CÃ“DIGO:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
$sql = "SELECT * FROM usuarios WHERE email = ?";
$stmt = $pdo->prepare($sql);
$stmt->execute([':email' => $email]);  â† ParÃ¡metro seguro

O con named parameters:
$sql = "SELECT * FROM usuarios WHERE email = :email";
$stmt = $pdo->prepare($sql);
$stmt->execute([':email' => $email]);  â† MÃ¡s claro


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
VERDAD #11: CONFIGURACIÃ“N DEBE CAMBIAR ENTRE AMBIENTES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

IMPORTANCIA: ALTA ğŸŸ¡

AMBIENTES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DESARROLLO (tu PC)
  db_host: localhost
  db_user: root
  db_pass: (vacÃ­o)
  jwt_secret: dev-key-xyz

PRODUCCIÃ“N (servidor)
  db_host: 192.168.x.x (servidor remoto)
  db_user: usuario_seguro
  db_pass: contraseÃ±a_fuerte
  jwt_secret: 7e2b3a1c9d5f4e8b...

PROBLEMA:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Si hardcodeas producciÃ³n en config.php:
  âŒ Al hacer test local, se conecta a servidor remoto
  âŒ Si expones repo en GitHub, credenciales pÃºblicas
  âŒ Posible hack

SOLUCIÃ“N (No implementada en este proyecto):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
MEJOR PRÃCTICA:
  .env.local
  .env.production

define('DB_HOST', getenv('DB_HOST') ?: 'localhost');

PARA ESTE PROYECTO:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… En desarrollo: Edita config.php con valores locales
âœ… En producciÃ³n: Edita config.php con valores servidor
âŒ NUNCA commites config.php a GitHub


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
VERDAD #12: NO CONFUNDAS AUTENTICACIÃ“N CON AUTORIZACIÃ“N
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

IMPORTANCIA: ALTA ğŸŸ¡

AUTENTICACIÃ“N = Â¿QuiÃ©n eres?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Verificar que eres quien dices ser.

PROCESO:
  1. Ingresas email: juan@mail.com
  2. Ingresas password: MiPass123!
  3. Backend verifica: âœ… Credenciales correctas
  4. Se te otorga token JWT
  5. Ya estÃ¡s AUTENTICADO


AUTORIZACIÃ“N = Â¿QuÃ© puedes hacer?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Verificar quÃ© permisos tienes.

PROCESO:
  1. Haces request: POST /api/routes/create
  2. Token JWT presente âœ… AUTENTICADO
  3. Backend verifica rol en token: "cliente"
  4. Verifica: Â¿cliente puede crear rutas? NO
  5. Se rechaza request âŒ HTTP 403 FORBIDDEN


EJEMPLO:
â”€â”€â”€â”€â”€â”€â”€â”€â”€
Usuaria: MarÃ­a (cliente)
  âœ… Autenticada: Tiene token JWT vÃ¡lido
  âŒ No autorizada: No es admin, no puede crear rutas

Usuario: Luis (admin)
  âœ… Autenticado: Tiene token JWT vÃ¡lido
  âœ… Autorizado: Es admin, SÃ puede crear rutas

EN CÃ“DIGO:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// AUTENTICACION
AuthMiddleware::verify();  â† Â¿Token existe y es vÃ¡lido?

// AUTORIZACION
AuthMiddleware::verifyAdmin();  â† Â¿Usuario es admin?


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
VERDAD #13: LOS LOGS SON TU MEJOR DEBUG
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

IMPORTANCIA: ALTA ğŸŸ¡

QUÃ‰ HACER CUANDO ALGO NO FUNCIONA:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. No adivines
2. No llores
3. MIRA LOS LOGS

DÃ“NDE ESTÃN:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
backend/logs/error_YYYY-MM-DD.log

QUÃ‰ CONTENDRÃN:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[2026-02-04 10:30:45] Error: Table 'rutas_seguras.usuarios' doesn't exist
[2026-02-04 10:35:22] Error: CORS blocked from https://malicious.com
[2026-02-04 10:40:10] Error: JWT token expired

CÃ“MO LEER:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Abre archivo log mÃ¡s reciente
2. Lee timestamp y mensaje
3. Identifica patrÃ³n
4. Busca en documentaciÃ³n

REGISTRAR EVENTOS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… error_log("Usuario " . $userId . " login exitoso", 0);

IMPORTANTE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
En producciÃ³n:
  âœ… Revisa logs regularmente
  âœ… Configura alertas si hay errores
  âœ… Haz backup de logs


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
VERDAD #14: TESTING ES NO NEGOCIABLE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

IMPORTANCIA: ALTA ğŸŸ¡

ANTES DE PUBLICAR:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Prueba TODOS estos casos:

AUTENTICACIÃ“N:
  âœ… Registrar con datos vÃ¡lidos
  âœ… Registrar con email duplicado â†’ Error 422
  âœ… Registrar con password dÃ©bil â†’ Error 422
  âœ… Login con credenciales correctas
  âœ… Login con password incorrecto â†’ Error 401
  âœ… Login con usuario no existe â†’ Error 401
  âœ… Obtener perfil con JWT vÃ¡lido
  âœ… Obtener perfil sin JWT â†’ Error 401
  âœ… Obtener perfil con JWT expirado â†’ Error 401

RUTAS:
  âœ… Buscar rutas sin JWT (debe funcionar, pÃºblico)
  âœ… Buscar rutas con filtros
  âœ… Crear ruta como admin
  âœ… Crear ruta como cliente â†’ Error 403
  âœ… Obtener sugerencias origen
  âœ… Obtener sugerencias destino

ERRORES:
  âœ… JSON invÃ¡lido â†’ Error 400
  âœ… Content-Type incorrecto â†’ Error 400
  âœ… Endpoint no existe â†’ Error 404
  âœ… BD desconectada â†’ Error 500

SEGURIDAD:
  âœ… SQL injection intento bloqueado
  âœ… CORS desde dominio no autorizado bloqueado
  âœ… ContraseÃ±a hasheada en BD (no texto plano)


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
VERDAD #15: MANTÃ‰N TODO DOCUMENTADO Y VERSIONADO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

IMPORTANCIA: ALTA ğŸŸ¡

VERSIONADO (Git):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Cada cambio debe estar registrado:

git add .
git commit -m "feat: Agregar endpoint crear rutas"

BUENAS PRÃCTICAS:
  âœ… Commit frecuente (cada feature pequeÃ±a)
  âœ… Mensaje descriptivo
  âœ… NO commits "Fix", usa "Fix: descripciÃ³n"

DOCUMENTACIÃ“N:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Cada cambio en cÃ³digo debe reflejarse en docs:

Si agregaste endpoint:
  âœ… Actualiza DOCUMENTACION_COMPLETA.md
  âœ… Actualiza README.md
  âœ… Actualiza REACT_API_CONFIG.ts

Si cambias BD:
  âœ… Actualiza db_schema.sql
  âœ… Actualiza MAPA_MENTAL.txt
  âœ… Documenta migraciÃ³n

CHANGELOG:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
MantÃ©n registro de cambios:
  Version 1.0 - 2026-02-04
    âœ… AutenticaciÃ³n completa
    âœ… BÃºsqueda rutas
    âœ… BD normalizada

  Version 1.1 - 2026-02-11
    âœ… Recuperar contraseÃ±a (agregar)
    âœ… Login social Google (agregar)
    âŒ Remover bÃºsqueda avanzada (deprecar)


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
RESUMEN: LAS 15 VERDADES MÃS IMPORTANTES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. ğŸ”´ JWT expira 24h â†’ Usuarios reloguean despuÃ©s
2. ğŸ”´ JWT_SECRET es llave maestra â†’ Cambiar en producciÃ³n
3. ğŸ”´ ContraseÃ±a BCRYPT irreversible â†’ No se puede recuperar, solo resetear
4. ğŸŸ¡ BD es fuente de verdad â†’ localStorage es solo cache
5. ğŸŸ¡ CORS es protecciÃ³n â†’ Configura dominio correcto
6. ğŸŸ¡ ValidaciÃ³n 4 niveles â†’ Frontend, middleware, lÃ³gica, BD
7. ğŸ”´ Nunca expongas errores â†’ Mensajes genÃ©ricos en producciÃ³n
8. ğŸŸ¡ Soft delete preserva datos â†’ AuditorÃ­a e integridad
9. ğŸŸ¡ Database Singleton â†’ Una conexiÃ³n para toda app
10. ğŸ”´ Prepared statements previenen SQL injection â†’ Siempre Ãºsalos
11. ğŸŸ¡ Config cambia por ambiente â†’ Desarrollo â‰  ProducciÃ³n
12. ğŸŸ¡ Autentica â‰  Autoriza â†’ Ambos necesarios
13. ğŸŸ¡ Logs son debug â†’ RevÃ­salos cuando fallos
14. ğŸŸ¡ Testing es no negociable â†’ Prueba todo antes de publicar
15. ğŸŸ¡ DocumentaciÃ³n y versionado â†’ MantÃ©n control de cambios

Â¡IMPORTANTE: Memoriza estas 15 verdades para ser backend dev profesional! ğŸš€


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FIN DE VERDADES IMPORTANTES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
